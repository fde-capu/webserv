# (*) optional = at least one must be done.

#user  nobody;
worker_processes  1;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;


events {
	worker_connections  1024;
}


http {
#    include       mime.types;
	default_type  application/octet-stream;

#log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
#                  '$status $body_bytes_sent "$http_referer" '
#                  '"$http_user_agent" "$http_x_forwarded_for"';

#access_log  logs/access.log  main;

	sendfile        on;
#tcp_nopush     on;

#keepalive_timeout  0;
	keepalive_timeout  65;

	client_max_body_size	200; # able to set max_body_size
#   From: https://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size
#	Syntax:		client_max_body_size size;
#	Default:	client_max_body_size 1m;
#	Context:	http, server, location
#	Sets the maximum allowed size of the client request body. If the size in a
#	request exceeds the configured value, the 413 (Request Entity Too Large)
#	error is returned to the client. Please be aware that browsers cannot
#	correctly display this error. Setting size to 0 disables checking of
#	client request body size.

#gzip  on;

		server {
			listen       3490;
			server_name  localhost;

#charset koi8-r;

#access_log  logs/host.access.log  main;

			client_max_body_size	100; # client_max_body_size works nested.

				location / { # nginx accept subdirectories. Optional (*).
					root   html;
					index  index.html index.htm; # default file to serve if none given, optional. (*)

					client_max_body_size	50; # client_max_body_size works nested.

						if ( $request_method !~ ^(GET|POST|DELETE)$ ) { # list of accepted methods, optional (*).
							return 405;
						}

					autoindex on; # Optional on/off (*).
				}

#error_page  404              /404.html;

# redirect server error pages to the static page /50x.html
#
			error_page   500 502 503 504  /50x.html; # setup default error pages.
				location = /50x.html {
					root   html;
				}

location ~ \.php$ { # Optional, 1 CGI, (bonus > 1, mandatory must be perfect). (*)
    root           html;
    fastcgi_pass   127.0.0.1:9000;
    fastcgi_index  index.php;
    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
    include        fastcgi_params;
}

# deny access to .htaccess files, if Apache's document root
# concurs with nginx's one
#
#location ~ /\.ht {
#    deny  all;
#}
		}

	server {
		listen			3491; # set port
			server_name		localhostB3491; # set server_names (or not);
		location / {
			root   htmlB3491;
			index  index.html index.htm;

			if ( $request_method !~ ^(GET)$ ) { # list of accepted methods. Optional (*)
				return 405;
			}
		}
	}

	server {
		listen			3492; # set port
# server_name	localhostC3492; # (set server_names) or not;
	}

	server { # first server of localhost:3490 is above, so this is ignored.
		listen       3490;
		server_name  localhost;
	}

	server { # if called as localhostB3491:3490, this should be executed,
		listen		3490; # and not be captured by localhost:3490.
			server_name	localhostB3491;
	}

	server {
		listen		3493;
		server_name	local-redirect localhost; # multiple server_name; bonus.
		return 301 http://localhost:3490; # optional (*)
	}

# another virtual host using mix of IP-, name-, and port-based configuration
#
#server {
#    listen       8000;
#    listen       somename:803491;
#    server_name  somename  alias  another.alias;

#    location / {
#        root   html;
#        index  index.html index.htm;
#    }
#}


# HTTPS server
#
#server {
#    listen       443 ssl;
#    server_name  localhost;

#    ssl_certificate      cert.pem;
#    ssl_certificate_key  cert.key;

#    ssl_session_cache    shared:SSL:1m;
#    ssl_session_timeout  5m;

#    ssl_ciphers  HIGH:!aNULL:!MD5;
#    ssl_prefer_server_ciphers  on;

#    location / {
#        root   html;
#        index  index.html index.htm;
#    }
#}

}
